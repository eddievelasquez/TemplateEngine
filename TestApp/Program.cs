// Module Name: Program.cs
// Author:      Eduardo Velasquez
// Copyright (c) 2025, Intercode Consulting, Inc.

#define USE_SLOTS

using System.Diagnostics;
using System.Globalization;
using System.Text;
using Intercode.Toolbox.TemplateEngine;

const string TemplateText = """
  // <auto-generated> This file has been auto generated by Intercode Toolbox Typed Primitives. </auto-generated>
  #nullable enable

  namespace $Namespace$;

  public partial class $TypeName$SystemTextJsonConverter: global::System.Text.Json.Serialization.JsonConverter<$TypeQualifiedName$>
  {
    public override bool CanConvert(
      global::System.Type typeToConvert )
    {
      return typeToConvert == typeof( $TypeQualifiedName$ );
    }

    public override $TypeQualifiedName$ Read(
      ref global::System.Text.Json.Utf8JsonReader reader,
      global::System.Type typeToConvert,
      global::System.Text.Json.JsonSerializerOptions options )
    {
      $TypeKeyword$? value = null;
      if( reader.TokenType != global::System.Text.Json.JsonTokenType.Null )
      {
        if( reader.TokenType == global::System.Text.Json.JsonTokenType.$JsonTokenType$ )
        {
          value = $JsonReader$;
        }
        else
        {
          bool converted = false;
          ConvertToPartial( ref reader, typeToConvert, options, ref value, ref converted );

          if ( !converted )
          {
            throw new global::System.Text.Json.JsonException( "Value must be a $JsonTokenType$" );
          }
        }
      }

      var result = $TypeQualifiedName$.Create( value );
      if( result.IsFailed )
      {
        throw new global::System.Text.Json.JsonException(
          global::System.Linq.Enumerable.First( result.Errors )
                .Message
        );
      }

      return result.Value;
    }

    public override void Write(
      global::System.Text.Json.Utf8JsonWriter writer,
      $TypeQualifiedName$ value,
      global::System.Text.Json.JsonSerializerOptions options )
    {
      if ( value.IsDefault )
      {
        writer.WriteNullValue();
        return;
      }

      $JsonWriter$;
    }

    partial void ConvertToPartial(
      ref global::System.Text.Json.Utf8JsonReader reader,
      global::System.Type typeToConvert,
      global::System.Text.Json.JsonSerializerOptions options,
      ref $TypeKeyword$? value,
      ref bool converted );
  }
  """;

// String.Format-compatible copy of TemplateText. All non-placeholder braces are escaped.
const string TemplateTextFormat = """
  // <auto-generated> This file has been auto generated by Intercode Toolbox Typed Primitives. </auto-generated>
  #nullable enable

  namespace {0};

  public partial class {1}SystemTextJsonConverter: global::System.Text.Json.Serialization.JsonConverter<{2}>
  {{
    public override bool CanConvert(
      global::System.Type typeToConvert )
    {{
      return typeToConvert == typeof( {2} );
    }}

    public override {2} Read(
      ref global::System.Text.Json.Utf8JsonReader reader,
      global::System.Type typeToConvert,
      global::System.Text.Json.JsonSerializerOptions options )
    {{
      {3}? value = null;
      if( reader.TokenType != global::System.Text.Json.JsonTokenType.Null )
      {{

        if( reader.TokenType == global::System.Text.Json.JsonTokenType.{4} )
        {{
          value = {5};
        }}
        else
        {{
          bool converted = false;
          ConvertToPartial( ref reader, typeToConvert, options, ref value, ref converted );

          if ( !converted )
          {{
            throw new global::System.Text.Json.JsonException( "Value must be a {4}" );
          }}
        }}
      }}

      var result = {2}.Create( value );
      if( result.IsFailed )
      {{
        throw new global::System.Text.Json.JsonException(
          global::System.Linq.Enumerable.First( result.Errors )
                .Message
        );
      }}

      return result.Value;
    }}

    public override void Write(
      global::System.Text.Json.Utf8JsonWriter writer,
      {2} value,
      global::System.Text.Json.JsonSerializerOptions options )
    {{
      if ( value.IsDefault )
      {{
        writer.WriteNullValue();
        return;
      }}

      {6};
    }}

    partial void ConvertToPartial(
      ref global::System.Text.Json.Utf8JsonReader reader,
      global::System.Type typeToConvert,
      global::System.Text.Json.JsonSerializerOptions options,
      ref {3}? value,
      ref bool converted );
  }}
  """;

var macroTable = new MacroTableBuilder()
                 .Declare( "Namespace" )
                 .Declare( "TypeName" )
                 .Declare( "TypeQualifiedName" )
                 .Declare( "TypeKeyword" )
                 .Declare( "JsonTokenType" )
                 .Declare( "JsonReader" )
                 .Declare( "JsonWriter" )
                 .Build();

var template = TemplateCompiler.Compile( TemplateText, macroTable );

const int Iterations = 1_000_000;

// Using explicit string array
var stringArgs = new string[7];
stringArgs[0] = "MyApp.Primitives"; // {0}
stringArgs[3] = "string"; // {3}
stringArgs[4] = "String"; // {4}
stringArgs[5] = "reader.GetString()"; // {5}
stringArgs[6] = "writer.WriteStringValue( value.Value );"; // {6}

Profile(
  "MacroProcessor.ProcessMacros with string array",
  () =>
  {
    for( var i = 0; i < Iterations; i++ )
    {
      stringArgs[1] = $"Type{i}"; // {1}
      stringArgs[2] = $"MyApp.Primitives.Type{i}"; // {2}

      var processed = template.ProcessMacros( stringArgs );
    }
  }
);

// Using explicit string array
var macroValues = macroTable.CreateValues();
macroValues.SetValue( 1, "MyApp.Primitives" );
macroValues.SetValue( 4, "string" );
macroValues.SetValue( 5, "String" ); // {4}
macroValues.SetValue( 6, "reader.GetString()" ); // {5}
macroValues.SetValue( 7, "writer.WriteStringValue( value.Value );" );

Profile(
  "MacroProcessor.ProcessMacros with MacroValues",
  () =>
  {
    for( var i = 0; i < Iterations; i++ )
    {
      macroValues.SetValue( 2, $"Type{i}" );
      macroValues.SetValue( 3, $"MyApp.Primitives.Type{i}" );

      var processed = template.ProcessMacros( macroValues );
    }
  }
);

// Using string params
Profile(
  "MacroProcessor.ProcessMacros with string params",
  () =>
  {
    for( var i = 0; i < Iterations; i++ )
    {
      var processed = template.ProcessMacros(
        "MyApp.Primitives",
        $"Type{i}",
        $"MyApp.Primitives.Type{i}",
        "string",
        "String",
        "reader.GetString()",
        "writer.WriteStringValue( value.Value )"
      );
    }
  }
);

// String.Format benchmark using the format-compatible template
var formatArgs = new object[7];
formatArgs[0] = "MyApp.Primitives"; // {0}
formatArgs[3] = "string"; // {3}
formatArgs[4] = "String"; // {4}
formatArgs[5] = "reader.GetString()"; // {5}
formatArgs[6] = "writer.WriteStringValue( value.Value );"; // {6}

Profile(
  "String.Format",
  () =>
  {
    for( var i = 0; i < Iterations; i++ )
    {
      formatArgs[1] = $"Type{i}"; // {1}
      formatArgs[2] = $"MyApp.Primitives.Type{i}"; // {2}

      var formatted = string.Format( TemplateTextFormat, formatArgs );
    }
  }
);

// Pre-parse the format string once to avoid repeated parsing cost in the loop
var templateCompositeFormat = CompositeFormat.Parse( TemplateTextFormat );

// Optimized String.Format using pre-parsed CompositeFormat and a reused args array to avoid per-call allocations
var compositeArgs = new object[7];
compositeArgs[0] = "MyApp.Primitives"; // {0}
compositeArgs[3] = "string"; // {3}
compositeArgs[4] = "String"; // {4}
compositeArgs[5] = "reader.GetString()"; // {5}
compositeArgs[6] = "writer.WriteStringValue( value.Value );"; // {6}

Profile(
  "CompositeFormat",
  () =>
  {
    for( var i = 0; i < Iterations; i++ )
    {
      compositeArgs[1] = $"Type{i}"; // {1}
      compositeArgs[2] = $"MyApp.Primitives.Type{i}"; // {2}

      var formatted = string.Format(
        CultureInfo.InvariantCulture,
        templateCompositeFormat,
        compositeArgs
      );
    }
  }
);

return;

static void Profile(
  string method,
  Action action )
{
  var timer = Stopwatch.StartNew();
  action();
  timer.Stop();

  ReportElapsed( method, timer );
}

static void ReportElapsed(
  string method,
  Stopwatch timer )
{
  var elapsed = timer.Elapsed;

  Console.WriteLine(
    $"Formatted {Iterations:N0} templates with {method} in {CalcElapsed( elapsed.TotalNanoseconds )} ({CalcElapsed( elapsed.TotalNanoseconds / Iterations )} per template)"
  );
}

static string CalcElapsed(
  double totalNanoseconds )
{
  if( totalNanoseconds >= 1_000_000_000L )
  {
    return $"{totalNanoseconds / 1_000_000_000.0:N2} s";
  }

  if( totalNanoseconds >= 1_000_000L )
  {
    return $"{totalNanoseconds / 1_000_000.0:N2} ms";
  }

  if( totalNanoseconds >= 1_000L )
  {
    return $"{totalNanoseconds / 1_000.0:N2} Âµs";
  }

  return $"{totalNanoseconds:N2} ns";
}
